{% comment %}
Create form populated by collection's product types and product tags

Accepts:
- collection: {Object} Collection Liquid object (required)

Usage:
{% render 'collection-filter', collection: collection %}
{% endcomment %}
{% assign separator = settings.filter__separator %}

{% comment %}Sanitize input to be case insensitive and strip additional spaces and remove repeats{% endcomment %}
{% assign categories = settings.filter__prefix | remove: ' ' | downcase | split: ',' | uniq %}

<aside class="collection__filter filter">

    <section class="filter__selected-tags"></section>

    <form class="filter__form">
        <h2 class="filter__title">Filter</h2>
        <ul class="filter__categories">
            {% for category in categories %}
                {% render 'filter-category', tags: collection.all_tags, category: category %}
            {% endfor %}
        </ul>

        <input type="submit" value="Filter products" class="filter__submit">

    </form>
    
</aside>

<script>

    const tagCounts = document.querySelectorAll('.category__tag-count');
    const allProducts = {{collection.all_products | json}};

    {% comment %} console.log(allProducts); {% endcomment %}
    
    const tags = document.querySelectorAll('.category__checkbox');

    addTagListeners();

    tagCounts.forEach(tag => {
        getProductCount(tag)
    });


    
    function addTagListeners() {
        tags.forEach(tag => {
            tag.addEventListener('change', () => {
                updateURL(tag);
                updateProducts();
                });
        });
    }


    {% comment %} avoid nesting for loops to search for duplicates {% endcomment %}
    {% comment %} if there are duplicates, that means there was at least one match {% endcomment %}
    function checkMatch(selectedTags, productTags) {
        const comboArr = [...selectedTags, ...productTags];
        const comboSet = [...new Set(comboArr)];
        return comboSet.length < comboArr.length;
    }
    
    function updateProducts() {
        let selectedTags = [...tags].filter(tags => tags.checked).map(el => el.dataset.tag);
        let matchingProducts = [...allProducts];
        matchingProducts = matchingProducts.filter(product => checkMatch(selectedTags, product.tags));
        console.log(matchingProducts.map(product => product.id));
    }

    {% comment %}
        Takes a string representation of anchor element and returns text in href attr
        @param {String} str Stringified anchor element    
        @return {String} Text within href attribute of str
    {% endcomment %}
    function parseAnchorStr(str) {
        const regex = /\/collections(.*?)"/gm;
        let href = str.match(regex);
        href = href[0].split('"');
        return href[0];
    }

    {% comment %}
        Change url based on state of tag and update history
        @param {Node} tag Checkbox clicked    
        @return {String} Text within href attribute of str
    {% endcomment %}
    function updateURL(input) {
        const handle = input.dataset.handle;
        const urlParams = getUrlParams();
        const [collection, tagHandles, sort] = urlParams;
        
        const updatedHandles = (input.checked) ? addHandle(handle, tagHandles) : removeHandle(handle, tagHandles);
        const newPath = createPath(collection, updatedHandles, sort);
        
        {% comment %} window.location.href = newPath; {% endcomment %}
        
        window.history.pushState({}, '', newPath);
    }

    function createPath(collection, handles, sort) {
        const handlesPath = handles ? `/${handles}` : '';
        const sortPath = sort ? `?sort_by=${sort}` : '';
        return collection + handlesPath + sortPath;
    }

    function getUrlParams() {
        const url = new URL(location);
        const collectionPath = '{{collection.url}}';
        const sortParam = url.searchParams.get('sort_by');
        
        let tagHandles = url.toString().split(collectionPath);
        tagHandles = tagHandles[1];

        if (sortParam) tagHandles = (tagHandles.split('?'))[0];

        tagHandles = tagHandles.slice(1);
        
        return [collectionPath, tagHandles, sortParam];
    }

    function addHandle(handle, tagHandles) {
        return (!tagHandles) ? handle : `${tagHandles}+${handle}`;
    }

    function removeHandle(handle, tagHandles) {
        return tagHandles.split('+').filter(_handle => _handle !== handle).join('+');
    }

    function getProductCount(el) {
        const tag = el.dataset.tag;
        const matchingProducts = allProducts.filter(product => product.tags.includes(tag));
        el.innerText = `(${matchingProducts.length})`;
    }



</script>